# 3주차 리팩토링 정리

## 구현하면서 마주한 문제점

    1. 피드백과 요구사항을 잘 반영했는가?
    2. resultMap 관련 하드코딩한 메서드들 고치기
    3. MVC에서 controller는 어디에서 호출해줘야할까?
    4. static은 어떨 때 써줘야 할까?
        - 접근제어자까지 고려해보기
    5. 테스트 코드에서 UI 관련 로직 제거하기
    6. 테스트 작성 이유 정리

## 문제 1. 피드백과 요구사항을 잘 반영했는가?

### 2주차 피드백 정리

- README.md를 상세히 작성하자. 어떤 프로젝트인지, 주요 기능이 무엇인지 적는다.
- 기능 목록에 구현과 같은 상세한 내용이나, 클래스 이름 등을 적지 않는다.
- 예외 상황도 함께 정리한다.
- 기능 목록을 업데이트 한다. 시작부터 모든 기능을 완벽하게 정리해야 한다는 부담을 갖기보다는, 기능을 구현하며서 지속적으로 업데이트하는 것을 목표로 한다.
- **값을 하드 코딩하지 않는다. static final(상수)를 정의하고 이름을 부여하여 해당 값이 어떤 역할을 하는지 명확히 드러낸다.**
- **구현 순서도 코딩 컨벤션이다.**
- 변수 이름에 자료형은 사용하지 않는다.
- **한 메서드가 한 가지 기능만 담당하게 한다.**
- 메서드가 한 가지 기능을 하는지 확인하는 기준을 세운다. 15라인이 넘지 않도록 의시적으로 메서드를 분리해보자.
- **테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다.**

- 처음부터 큰 단위의 테스트를 만들지 않는다.

### 보완할 부분

1. 값을 하드코딩 하지 않고 상수 static final를 이용하였나
2. 클래스 구현 순서를 잘 지켰나
3. 메서드를 최소 기능으로 쪼개었는가

### 1. 값을 하드코딩 하지 않고 상수 static final를 이용하였나

상수를 저장하는 목적으로 Enum을 사용했었다.

### 배움 1. Enum은 연관된 값을 엮어주기 위해 사용하는 것이다.

Enum은 연관된 값들의 관계를 볼 수 있게끔 묶어주는 역할의 클래스이기 때문에, 내가 Enum으로 정의했던 PrintConstants는 Enum보다는 상수에 어울릴 것 같다고 생각해 리팩토링 해주었다.

### 2. 클래스 구현 순서를 잘 지켰나

피드백에서 클래스 구현 순서도 컨벤션이라는 내용이 있었다.

> 클래스는 `상수 또는 클래스 변수, 멤버 변수, 생성자, 메서드` 순으로 작성한다.

해당 컨벤션을 잘 지켜주었는지 확인하여 변경해주었다.

### 3. 메서드를 최소 기능으로 쪼개었는가

로또를 발행하고 MyLottos 클래스에 저장하는 메서드가 (1) 발행하는 로직과 (2) 발행된 것을 반환하는 View 호출 로직이 함께 있어 분리가 필요해보인다.

![alt text](<../img/스크린샷 2024-11-02 오전 11.05.43.png>)
위와 같았던 코드를 아래처럼 변경하였다.

![alt text](<../img/스크린샷 2024-11-02 오전 11.15.06.png>)

<br>
<br>

테스트 코드 관련된 피드백은 맨 마지막에 확인하고 정리하도록 하겠다.

---

## 2. resultMap 관련 하드코딩한 메서드들 고치기

WinningTotalController에서 당첨 결과를 담는 map을 만들 때 일일이 하드코딩해 저장하는 makeResultMap을 만들었다.
![alt text](<../img/스크린샷 2024-11-02 오전 11.26.14.png>)
Enum의 values를 이용하면 하드코딩하지 않고 map을 만들 수 있을 것 같아 수정해보도록 하겠다.
![alt text](<../img/스크린샷 2024-11-02 오전 11.29.40.png>)
위와 같이 변경하여 하드코딩 없이, 내용에 대한 공개 없이 map을 생성할 수 있게 되었다.

다른 부분에서도 로직 때문에 어쩔 수 없이 하드코딩했던 것을 하드코딩하지 않는 방법으로 변경해보고 싶다.

### 배움 2. Enum에서 static으로 메서드를 만들면 외부에서 이용할 수 있다...!(넘나 유용)

Enum에서 순위 이름으로 내용을 찾는 것은 getter함수로 쉬웠지만, 순위 내용으로 이름을 찾는 것은 불가능한 일인 줄 알았다. 검색해보니 static 메서드를 선언해 로직을 구현하면 가능했다.
![alt text](<../img/스크린샷 2024-11-02 오전 11.50.21.png>)
위와 같이 구현하면 Enum이름.getNameByMatchNumber()로 외부에서 Enum 객체의 이름을 찾을 수 있게 된다.
![alt text](<../img/스크린샷 2024-11-02 오전 11.54.14.png>)
하드코딩 없는 메서드로 변경 성공!!넘 뿌듯하고 재밌다.

## 문제 3. MVC에서 controller는 어디에서 호출해줘야할까?

LottoController에서 다른 기능들의 controller를 불러오면서 특별한 변경이 없는데도 메서드 내에서 객체를 선언하는 것이 불필요해보였다.

![alt text](<../img/스크린샷 2024-11-02 오후 2.05.34.png>)
검색을 해보니, **의존성 주입** 방식을 써주는 것이 좋다는 이야기를 찾을 수 있었다. 결합도가 줄어들고, 테스트하기에 편리해진다는 장점이 있다.

LottoController 안에서 모든 기능을 수행하는 controller를 실행하는 것이 역할이 명확하지 않다는 단점이 있다. controller로 분리했던 기능을 담당하는 로직들을 Service로 빼주는 게 좋을 것 같다.

### 배움 3. controller는 호출과 전달의 역할만 할 수 있도록 만들어야겠다.

![alt text](<../img/스크린샷 2024-11-02 오후 3.27.26.png>)
미치도록 긴 의존성 주입...

LottoController 안에 있는 init 메서드가 너무 길다는 생각을 하기 시작했다.

> 변경 전
> ![](<../img/스크린샷 2024-11-02 오후 3.47.11.png>)
> 변경 후
> ![alt text](<../img/스크린샷 2024-11-02 오후 3.45.11.png>)

홀쭉해진 (전)init, (현) startLottery....

보기도 훨씬 좋은 것 같다. view 함수까지 같이 init에 담아버리니까 어디부터 어디까지 하나의 기능인지 보는게 어려웠는데, 나누고나니 꽤 수월해졌다.

## 문제 4. static은 어떨 때 써줘야 할까?

- 모든 인스턴스에서 공통으로 사용하는 멤버 변수
- 인스턴스를 변경하지 않는 메서드
- 인스턴스 변수를 사용하지 않는다면, static 붙이는 후보에 두자
- 모든 인스턴스에서 공통된 값을 유지해야 하는 경우

> 클래스의 인스턴스가 생성될 때마다 다른 값을 가져야 하는지를 생각하면 구분이 쉬워질 것 같다. 굳이 다를 필요 없는 부분에서는 한번만 생성해서 사용하는 개념으로 static으로 선언하면 될 것 같다고 이해했다.

## 문제 5. 테스트 코드에서 UI 관련 로직 제거하기

입출력(UI)을 비교하는 테스트코드를 제외하라는 피드백이 있었다.
나도 제대로 값을 내보내는지를 비교하는 테스트 코드를 작성했었는데, 값 자체를 equals로 비교해주는 방식으로 변경하였다.

## 문제 6. 테스트 작성 이유 정리하기

1. 구현 내용 및 에러를 확인하기 위해서 같은 내용을 일일이 타이핑할 필요 없다.

   테스트 코드를 작성하기 전, 간단한 것을 코드로 작성할 때는 매번 실행시켜서 입력값을 직접 하드코딩하면 된다거나, 편하게 변수로 저장해놓고 사용하는 경우가 잦았다. 당시엔 테스트가 필요하지 않다고 생각했었지만 점점 큰 규모의 입력, 다양한 예외 처리가 필요한 상황에서는 직접 입력하는 것에 시간을 많이 할애해야 했다. 테스트 코드가 있으면 인간이 일일이 타이핑하면서 할애하는 시간과 발생하는 실수 등에 영향을 받지 않고 구현된 기능을 검사할 수 있다.

2. 시간을 측정할 수 있다.

   구현의 규모가 커지면서 코드가 복잡해지면, 실행 시간도 그만큼 오래 걸린다. 테스트 코드의 장점은 다양한 로직의 시간을 측정하고 한번에 비교할 수 있다는 것이다.

3. 작은 공백까지도 체크할 수 있다.

   정해진 문제의 형식이 있는 경우가 있다. 단순히 콘솔 입출력으로 확인한다면 발견하지 못할 공백과 작은 문자에 따른 에러까지도 비교할 수 있어 정확도가 올라간다.

4. 무엇보다...한 번에 모든 케이스를 테스트할 수 있다.....

   테스트 코드를 작성하면서 너무나도 좋았던 점은 단위테스트 코드로 촘촘하게 작성하고 기능을 구현한 다음, "폴더 단위"로도 테스트 코드를 실행할 수 있다는 점이다! 이것이 리팩토링할 때 정말 유용하고 좋았다. 전체적으로 잘 돌아가는 시스템에서 내가 어떤 부분을 놓쳐서 에러가 났는지 정확하게 알 수 있고, 얼마나 개선했는지도 알 수 있으며, 한번에 모든 기능을 다시 체크함으로써 리팩토링을 잘 끝마쳤다는 지표도 된다. 이것을 몰랐을 때는 테스트 코드가 담긴 폴더 안에서 파일을 나누는 것이 무서웠는데, 폴더 단위로 돌릴 수 있음을 알게 된 후 기능 별로 겁없이 늘리고, 마음 편하게 테스트하면서 개발의 질을 높일 수 있었다...!

## 문제 7. README.md 수정하기

완료~~~~~~~
